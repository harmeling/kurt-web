; first order logic

;; syntax
load propositional  ; syntax and rules for propositional logic
arity  forall 2       ; universal quantification
arity  exists 2       ; existential quantification
bindop forall, exists
bool   forall 0 2     ; position 1 is a variable or a boolean expression (with a variable)
bool   exists 0 2     ; position 1 is a variable or a boolean expression (with a variable)
alias  ∃ exists
alias  ∀ forall

;; inference rules
;use %A                                  implies  forall $x %A      "forall-intro"
use forall $x %A                        implies  sub $x $a %A      "forall-elim"
use sub $x $a %A                        implies  exists $x %A      "exists-intro"
;use (exists $x %B) and (%B implies %A)  implies  %A                "exists-elim"

;; better looking
; use %A                     ⇒  ∀ $x %A       "forall-intro"
; use ∀ $x %A                ⇒  sub $x $a %A  "forall-elim"
; use sub $x $a %A           ⇒  ∃ $x %A       "exists-intro"      ; contraposition of "forall-elim"
; use (∃ $x %B) ∧ (%B ⇒ %A)  ⇒  %A            "exists-elim"

;; requirements
; - for "forall-intro":
;   - no requirements!  `$x` can appear in `%A` or not
; - for "forall-elim" and "exists-intro":
;   - `$a` doesn't contain free variables that are bound in `%A`
;   - already sufficient would be if those free variables in `$a` are not bound in `%A` only at the locations of `$x`
;   - can anything bad really happen, if we rename all variables (free and bound) beforehand?
;     - probably not, since we rename all vars in `%A` before `$a` is instantiated
; - for "exists-elim":
;   - `%A` must not contain `$x`
;   - since we first completely rename *all* variables this works:
;       (exists $%1 %B) and (%B implies %A)  implies  %A
;     where (for readability) we didn't replace `%A` and `%B`.  
;   - case 1: we first match `%B` using `exist $%1 %B`, then `%B` will contain `$%1`, next
;     we match `%B implies %A` where we can assign `$%1` appropriately, since it appears free
;   - case 2: we match `%B` using `%B implies %A`, then we use that `%B` to match against
;     `exists $%1 %B`
