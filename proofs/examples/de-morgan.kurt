; de Morgan's law
load propositional
var p, q       ; free variables

; axioms
use p ∨ ¬p         "excluded-middle"

; first law (proof with optional indentation)
show ¬(p∧q) ≡ ¬p ∨ ¬q    "de-morgan"
proof
    show  ¬(p∧q) ⇒ ¬p ∨ ¬q
    proof
        fix p, q                   ; locally make them constants
            assume ¬(p∧q)          ; opens a block
                assume p           ; opens a block
                    assume q       ; opens a block
                        p ∧ q      ; and-intro
                        ⊥          ; bottom-intro
                    thus ¬q        ; not-intro, closes the block opened by `assume q`
                    ¬p ∨ ¬q        ; or-intro
                thus p ⇒ ¬p ∨ ¬q   ; impl-intro, closes the block opened by `assume p`
                assume ¬p
                    ¬p ∨ ¬q        ; or-intro
                thus ¬p ⇒ ¬p ∨ ¬q  ; impl-intro, closes the block opened by `assume ¬q`
                p ∨ ¬p             ; excluded-middle, restatement
                ¬p ∨ ¬q            ; or-elim
            thus ¬(p∧q) ⇒ ¬p ∨ ¬q  ; impl-intro, closes the block opened by `assume ¬(p∧q)`
        thus ¬(p∧q) ⇒ ¬p ∨ ¬q      ; impl-intro, closes the block opened by `fix p, q`
    qed
    show ¬p ∨ ¬q ⇒ ¬(p∧q)
    proof
        fix p, q                   ; locally make them constants
            assume ¬p ∨ ¬q         ; opens a block
                assume ¬p          ; opens a block
                    assume p∧q     ; opens a block
                        p          ; and-elim
                        ⊥          ; bottom-intro
                    thus ¬(p∧q)    ; impl-intro, closes the block opened by `assume p∧q`
                thus ¬p ⇒ ¬(p∧q)   ; impl-intro, closes the block opened by `assume ¬p`
                assume ¬q
                    assume p∧q
                        q          ; and-elim
                        ⊥          ; bottom-intro
                    thus ¬(p∧q)    ; not-intro, closes the block opened by `assume p∧q`
                thus ¬q ⇒ ¬(p∧q)   ; impl-intro, closes the block opened by `assume ¬q`
                ¬(p∧q)             ; impl-elim
            thus ¬p ∨ ¬q ⇒ ¬(p∧q)  ; impl-intro, closes the block opened by `assume ¬p ∨ ¬q`
        thus ¬p ∨ ¬q ⇒ ¬(p∧q)      ; forall-intro, closes the block opened by `fix p, q`
    qed
    ¬(p∧q) ≡ ¬p ∨ ¬q               ; iff-intro
qed

;; second law (proof without indentation)
show ¬(p∨q) ≡ ¬p ∧ ¬q        "de-morgan"
proof
    show ¬(p∨q) ⇒ ¬p ∧ ¬q
    proof
        fix p, q
        assume ¬(p∨q)
        assume p
        p ∨ q
        ⊥
        thus p ⇒ ⊥
        ¬p
        assume q
        p ∨ q
        ⊥
        thus q ⇒ ⊥
        ¬q
        ¬p ∧ ¬q
        thus ¬(p∨q) ⇒ ¬p ∧ ¬q
        thus ¬(p∨q) ⇒ ¬p ∧ ¬q
    qed
    show ¬p ∧ ¬q ⇒ ¬(p∨q)
    proof
        fix p, q             ; locally make them constants
        assume ¬p ∧ ¬q
        assume p∨q
        assume p
        ¬p
        ⊥
        thus p ⇒ ⊥
        assume q
        ¬q
        ⊥
        thus q ⇒ ⊥
        ⊥
        thus p∨q ⇒ ⊥
        ¬(p∨q)
        thus ¬p ∧ ¬q ⇒ ¬(p∨q)
        thus ¬p ∧ ¬q ⇒ ¬(p∨q)
    qed
    ¬(p∨q) ≡ ¬p ∧ ¬q
qed
;;; Proof checked.